// Manifold struct and partialDeriv function from
// https://graphics.pixar.com/library/BumpRoughness/

/*
# Copyright 2017 Pixar
#
# Licensed under the Apache License, Version 2.0 (the "Apache License")
# with the following modification; you may not use this file except in
# compliance with the Apache License and the following modification to it:
# Section 6. Trademarks. is deleted and replaced with:
#
# 6. Trademarks. This License does not grant permission to use the trade
#    names, trademarks, service marks, or product names of the Licensor
#    and its affiliates, except as required to comply with Section 4(c) of
#    the License and to reproduce the content of the NOTICE file.
#
# You may obtain a copy of the Apache License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the Apache License with the above modification is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the Apache License for the specific
# language governing permissions and limitations under the Apache License.
*/


struct Manifold{
    point Q;
    normal QN;
    float Qradius;
};

void partialDeriv(point Q, float a, float b,
                  output vector dQda, output vector dQdb)
{
    vector dQdx = Dx(Q);
    vector dQdy = Dy(Q);

    float A = Dx(a);
    float B = Dx(b);
    float C = Dy(a);
    float D = Dy(b);

    float invdet = 1/(A*D - B*C);

    dQda = (dQdx*D-dQdy*B)*invdet;
    dQdb = (dQdy*A-dQdx*C)*invdet;
}


// Seems prman calculates displacement and shading in different spaces
// So perform all calculations and maintain "state" of
// manifold layers in "object" space but output N in "common"
shader displacementLayer(
    Manifold inLayer = {0},
    color input = 0,
    float gain = 1,
    int source = 0  [[
        string widget = "mapper",
        string options = "Scalar R:0|Scalar G:1|Scalar B:2|Vector:3",
    ]],
    int mode = 0,  // Original direction / recalculated

    output Manifold outLayer = {0},
    output normal displacedN = 0,
    output vector dispVector = 0,
)
{
    // Always initialize local variables to prevent NaNs
    point Po = 0;
    point localP = 0;
    normal localN = 0;

    getattribute("primvar", "P", Po);
    Po = transform("object", Po);

    localP = Po;
    if (isconnected(inLayer))
        localP = inLayer.Q;

    if (isconnected(inLayer) && mode)
        localN = inLayer.QN;
    else{
        getattribute("builtin", "Non", localN);
        localN = transform("object", localN);
    }

    localN = normalize(localN);

    if (source < 3){
        localP += localN * input[max(0, source)] * gain;
    }else if (source==3){
        float s = u;
        float t = v;
        vector tangent = 0;
        vector bitangent = 0;
        
        getattribute("primvar", "s", s);
        getattribute("primvar", "t", t);

        partialDeriv(localP, s, t, tangent, bitangent);

// The following mapping works well with EAR.exr from Arnold documentation
// https://help.autodesk.com/view/ARNOL/ENU/?guid=arnold_for_houdini_shading_ah_Combining_Regular_and_Vector_Displacement_Maps_html
// https://areadownloads.autodesk.com/wdm/arnold/htoa/vector-and-regular-displacement.zip
        vector disp = normalize(tangent) * input.r
                    + localN * input.g
                    + normalize(bitangent) * input.b;
        
        localP += disp * gain;
    }

    dispVector = localP - Po;
    displacedN = calculatenormal(localP);

    outLayer.Q = localP;
    outLayer.QN = displacedN;

    displacedN = transform("object", "common", displacedN);

    // The trick to make restored normals consistent
    if ((dot(displacedN, I) > 0) && (dot(N, I) < 0))
        displacedN = reflect(displacedN, I);  // Intentionally swap N and I

    displacedN = normalize(displacedN);
}