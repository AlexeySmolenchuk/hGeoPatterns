struct Manifold{
    point Q;
    normal QN;
    float Qradius;
};

// Seems prman calculates displacement and shading in different spaces
// So perform all calculations and maintain "state" of
// manifold layers in "object" space but output N in "common"
shader displacementLayer(
    Manifold inLayer = {0},
    float in = 0,
    float gain = 1,
    int mode = 0,  // Original direction / recalculated

    output Manifold outLayer = {0},
    output normal displacedN = 0,
    output vector dispVector = 0,
)
{
    // Always initialize local variables to prevent NaNs
    point Po = 0;
    point localP = 0;
    normal dispDirection = 0;

    getattribute("primvar", "P", Po);
    Po = transform("object", Po);

    localP = Po;
    if (isconnected(inLayer))
        localP = inLayer.Q;

    if (isconnected(inLayer) && mode)
        dispDirection = inLayer.QN;
    else{
        getattribute("builtin", "Non", dispDirection);
        dispDirection = transform("object", dispDirection);
    }

    dispDirection = normalize(dispDirection);
    localP += dispDirection * in * gain;

    dispVector = localP - Po;
    displacedN = calculatenormal(localP);

    outLayer.Q = localP;
    outLayer.QN = displacedN;

    displacedN = transform("object", "common", displacedN);

    // The trick to make restored normals consistent
    if ((dot(displacedN, I) > 0) && (dot(N, I) < 0))
        displacedN = reflect(displacedN, I);  // Intentionally swap N and I

    displacedN = normalize(displacedN);
}