#include "hGeoStructsOSL.h"

#define CAPACITY 8  // Capacity matches maximum number of sampled points
#define DECAL 1

vector build_coord_system(point pos, vector dir, normal n, point center, vector scale, float angle, float randomize){
    vector _u = normalize(dir);
    vector _v = normalize(cross(n, dir));
    _u = normalize(cross(_v, n));
    vector coord = pos - center;
    coord = vector(dot(coord, _u), dot(coord, _v), 0);

    if (angle !=0){
        float a = angle * M_PI;
        coord = vector( cos(a)*coord.x - sin(a)*coord.y, sin(a)*coord.x + cos(a)*coord.y, 0);
    }
    coord *= vector(1/scale.x, 1/scale.y, 1);
    // TODO: define outside
    coord += vector(noise("cell", center)-0.5) * randomize + 0.5;
    return coord;
}

void toArray(vector dest[CAPACITY], ArrayData data){
    dest[0] = data.v0;
    dest[1] = data.v1;
    dest[2] = data.v2;
    dest[3] = data.v3;
    dest[4] = data.v4;
    dest[5] = data.v5;
    dest[6] = data.v6;
    dest[7] = data.v7;
}

void toArray(float dest[CAPACITY], ArrayData data){
    dest[0] = data.v0.x;
    dest[1] = data.v1.x;
    dest[2] = data.v2.x;
    dest[3] = data.v3.x;
    dest[4] = data.v4.x;
    dest[5] = data.v5.x;
    dest[6] = data.v6.x;
    dest[7] = data.v7.x;
}

void toArray(int dest[CAPACITY], ArrayData data){
    dest[0] = int(round(data.v0.x));
    dest[1] = int(round(data.v1.x));
    dest[2] = int(round(data.v2.x));
    dest[3] = int(round(data.v3.x));
    dest[4] = int(round(data.v4.x));
    dest[5] = int(round(data.v5.x));
    dest[6] = int(round(data.v6.x));
    dest[7] = int(round(data.v7.x));
}


shader buildCoords (
    int style = 0 [[
        string widget = "mapper",
        string options = "Blend:0|Decals:1",
        int connectable = 0,
        ]],
    ArrayData Positions = {},
    ArrayData Normals = {},

    // Optional
    ArrayData Directions = {},
    ArrayData Scales = {},
    ArrayData Weights = {},
    ArrayData Indexes = {},

    float scalex = 1.0,
    float scaley = 1.0,
    vector defaultDirection = vector(0, 0, 1),
    float sharpness = 10.0,
    float angle = 0.0,
    float randomize = 1.0,

    point position = 0,

    output vector outCoords[CAPACITY] = {0},
    output vector outHashes[CAPACITY] = {0},
    output float outWeights[CAPACITY] = {0},
    output color DBG = 0
)
{
    point myP;
    if (isconnected(position))
        myP = position;
    else
        myP = transform("object", P);

    vector pos[CAPACITY];
    vector nrml[CAPACITY];
    vector dir[CAPACITY];
    vector scale[CAPACITY];

    toArray(pos,    Positions);
    toArray(nrml,   Normals);
    toArray(dir,    Directions);
    toArray(scale,  Scales);

    float r[CAPACITY];
    int n = Positions.num;

    if (isconnected(Indexes))
    {
        toArray(r, Indexes);
    }
    else
    {
        // If no Indexes provided generate Position based 1D array of randoms
        // to determine texture selection and overlapping presence
        for (int i=0; i<n; i++)
            r[i] = hashnoise(pos[i]);
    }

    int sorted[CAPACITY] = {0,1,2,3,4,5,6,7};

    if (style==DECAL) // Sort only for overlapping decals
        for (int i=0; i<n; i++){
            for (int j=i+1; j<n; j++){
                if (r[sorted[i]] < r[sorted[j]]){
                    int tmp = sorted[i];
                    sorted[i] = sorted[j];
                    sorted[j] = tmp;
                }
            }
        }

    // Assume presorted by distance (which is true for "samplePoints")
    float dist0 = distance(myP, pos[sorted[0]]);
    float overall_weight = 0;

    for (int i=0; i<n; i++)
    {
        int idx = sorted[i];
        outCoords[i] = build_coord_system( myP,
            isconnected(Directions) ? dir[idx] : transform("common", "object", defaultDirection),
            nrml[idx],
            pos[idx],
            (isconnected(Scales) ? scale[idx] : vector(1,1,1)) * vector(scalex, scaley, 0),
            angle,
            randomize);

        outHashes[i] = isconnected(Indexes) ? hashnoise(r[idx]) : hashnoise(pos[idx]);

        if (style==DECAL)
        {
            outWeights[i] = 1.0;
        }
        else
        {
            if (i==0)
                outWeights[i] = 1.0;
            else
            {
                outWeights[i] = pow( dist0 / ( dist0 + distance(myP, pos[idx]) ) * 2, sharpness);
                outWeights[i] = linearstep(0.01, 0.99, outWeights[i]);
            }

            overall_weight += outWeights[i];
        }
    }

    float inv = 1.0/overall_weight;
    for (int i = 0; i<n; i++){
        float frame = 1;
        if (style==DECAL)
        {
            vector tmp = abs(outCoords[i]-0.5);
            float d = max(tmp.x, tmp.y);
            frame = (d < 0.5) ? (d < 0.49) ? 0.1 : 1 : 0;
        }
        else
            outWeights[i] *= inv;

        DBG += outHashes[i] * frame * outWeights[i];
    }
}
